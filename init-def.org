* Emacs
** use a custom file
	 #+BEGIN_SRC emacs-lisp
(use-package emacs
	:init
	(setq custom-file
				"~/.emacs.d/custom-settings.el")
	(load custom-file t))
	 #+END_SRC
** setup
	 #+BEGIN_SRC emacs-lisp
(use-package emacs
	:config
	(show-paren-mode 1)
	(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
	(electric-pair-mode 1))
	 #+END_SRC
** variables
	 #+BEGIN_SRC emacs-lisp
(defvar conf "~/.emacs.d/init-def")
(defvar init-el (concat conf ".el"))
(defvar init-org (concat conf ".org"))
(setq font-scale 120)
	 #+END_SRC
** editing this file
	 #+BEGIN_SRC emacs-lisp
(use-package emacs
	:config
	(defun oct/init ()
		"Edit `org-file' in the current buffer"
		(interactive)
		(find-file init-org)))
	 #+END_SRC
** executing this file
	 I need a way to compile and then execute the whole init file.
	 this is helful for testing if I've fucked it up yet.
	 #+BEGIN_SRC emacs-lisp
(use-package emacs
	:config
	(defun oct/exec-init ()
		(interactive)
		(org-babel-load-file init-org)))
	 #+END_SRC
* GUI
** Basics
	 Trying to keep the interface minimal.
	 This means getting rid of tool and menu bars, stopping the startup screen, and bell.
	 We also add a fringe of 15px because I don't like when text is right on the edge.
	 #+BEGIN_SRC emacs-lisp
(use-package emacs
	:config
	(tool-bar-mode -1)
	(menu-bar-mode -1)
	(blink-cursor-mode -1)
	(scroll-bar-mode -1)
	(setq inhibit-startup-screen t)
	(setq ring-bell-function 'ignore)
	(set-fringe-mode 15))
	 #+END_SRC
** Set font properties and keybinds
	 #+BEGIN_SRC emacs-lisp
(use-package emacs
	:config
	;; set font scale to default
	(set-face-attribute 'default (selected-frame) :height font-scale)
	;; functions for font scale
	(defun oct/inc-scale ()
		"increases the frame's font scale"
		(interactive)
		(setq font-scale (+ font-scale 10))
		(set-face-attribute 'default (selected-frame) :height font-scale))
	(defun oct/dec-scale ()
		"decreases the frame's font scale"
		(interactive)
		(setq font-scale (- font-scale 10))
		(set-face-attribute 'default (selected-frame) :height font-scale))

	(set-face-attribute 'default nil :family "Hack" :height font-scale)
	:bind
	("C-=" . 'oct/inc-scale)
	("C--" . 'oct/dec-scale))
	 #+END_SRC

** olivetti
	 #+BEGIN_SRC emacs-lisp
(use-package olivetti
	:ensure t)
	 #+END_SRC
** diminish
	 #+BEGIN_SRC emacs-lisp
(use-package diminish :ensure)
(use-package undo-tree :diminish)
	 #+END_SRC
** Themes
*** custom themes
		we want to be able to load whatever custom themes we have so add them to the path
		#+BEGIN_SRC emacs-lisp
;; add theme directory
(add-to-list 'custom-theme-load-path "~/.emacs.d/themes/")
(add-to-list 'load-path "~/.emacs.d/themes/")
		#+END_SRC

		function to load a given theme
		#+BEGIN_SRC emacs-lisp
(defun oct/load-theme-silent (theme)
	"Reloads a THEME given by the user."
	(interactive
	 (list
		(intern
		 (completing-read "Load custom theme: "
											(mapcar #'symbol-name
															(custom-available-themes))))))
	(load-theme theme t))
		#+END_SRC

		function to load a theme from the current file
		#+BEGIN_SRC emacs-lisp
(defun oct/load-theme-from-curr ()
	(interactive)
	(intern
	 (oct/load-theme-silent (substring 
													 (file-name-nondirectory
														(buffer-file-name))
													 0 -9))))
		#+END_SRC
*** Set the theme
		#+BEGIN_SRC emacs-lisp
;; get this dope theme
;; (use-package modus-vivendi-theme
;; 		:ensure t)
(oct/load-theme-silent 'underwater)

		#+END_SRC
*** rainbow-mode
		#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
	:ensure
	:diminish
	:commands rainbow-mode
	:config
	(setq rainbow-ansi-colors nil)
	(setq rainbow-x-colors nil)
	(setq-default rainbow-mode 1))
		#+END_SRC
** line numbers
	 #+BEGIN_SRC emacs-lisp
(use-package emacs
	:config
	(column-number-mode)
	(global-display-line-numbers-mode t)
	(dolist (mode '(org-mode-hook
									term-mode-hook
									vterm-mode-hook))
		(add-hook mode (lambda ()
										 (display-line-numbers-mode 0)))))
	 #+END_SRC
** font

* Editor
** evil-mode
	 basic evil mode setup
#+BEGIN_SRC emacs-lisp
;; vim fusion
(use-package evil
:ensure t
:init
(setq evil-want-integration t)
(setq evil-want-keybinding nil)
:config
(evil-mode 1)
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
;; let us use evil mode in ibuffer
(setq evil-emacs-state-modes (delq 'ibuffer-mode evil-emacs-state-modes))
(add-to-list 'evil-emacs-state-modes 'vterm-mode)
(evil-global-set-key 'motion "j" 'evil-next-visual-line)
(evil-global-set-key 'motion "k" 'evil-previous-visual-line)
(evil-global-set-key 'motion "g(" 'backward-up-list)
(evil-global-set-key 'motion "g)" 'down-list))
#+END_SRC

	 Some functions for missing functionality
#+BEGIN_SRC emacs-lisp
;; (use-package evil
;; 	;; change :q to just killing the buffer
;; 	(evil-define-command evil-quit-current (&optional bang)
;; 		:repeat nil
;; 		(interactive "<!>")
;; 		;; if there are any other buffers just kill this one
;; 		(kill-buffer (current-buffer)))
;; 
;; 	;; change :wq to just writing and killing the buffer
;; 	(evil-define-command evil-write-quit-current (&optional bang)
;; 		:repeat nil
;; 		(interactive "<!>")
;; 		;; if there are any other buffers just kill this one
;; 		(save-buffer)
;; 		(kill-buffer (current-buffer)))
;; 	(evil-ex-define-cmd "q[uit]" 'evil-quit-current)
;; 	(evil-ex-define-cmd "wq" 'evil-write-quit-current))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(use-package evil-collection
	:ensure
	:after evil
	:config
	(evil-collection-init))
#+END_SRC
** settings
	 #+BEGIN_SRC emacs-lisp
(use-package emacs
	:config
	(setq-default tab-width 2)
	(setq-default c-basic-offset 2)
	(setq-default indet-tabs-mode nil))
	 #+END_SRC
** keys
this will probably need to be reorganized
#+BEGIN_SRC emacs-lisp
	(use-package general
		:ensure
		:config
		(general-evil-setup t)
		(general-create-definer oct/leader-keys
			:keymaps '(normal insert visual emacs)
			:prefix "SPC"
			:global-prefix "C-SPC")

		(oct/leader-keys
		 "g" '(:ignore t)
		 "gs" 'magit-status
		 "c" '(:ignore t)
		 "cc" 'oct/init
		 "cs" 'oct/exec-init))



#+END_SRC
* Buffers
** Functions
	 kill-curr-buff kills the current buffer and closes its window.
	 #+BEGIN_SRC emacs-lisp
(use-package emacs
	:config
	(defun oct/kill-curr-buff (&optional arg)
		"Kill the current buffer"
		;; make interactive, set arg to ???
		(interactive "p")
		;; we can't kill a minibuffer so abort it
		;; otherwise kill the buffer
		(if (minibufferp)
				(abort-recursive-edit)
			(kill-buffer (current-buffer)))
		;; if there are other windows we can kill this one
		(when (and arg
							 (not (one-window-p)))
			(delete-window)))

	:bind ("M-k" . oct/kill-curr-buff))
	 #+END_SRC
** IBuffer
	 Settings for ibuffer
	 #+BEGIN_SRC emacs-lisp
(use-package ibuffer
	:config
	(setq ibuffer-use-other-window nil)
	:bind
	(("C-x C-b" . ibuffer)))
	 #+END_SRC
** MiniBuffer
	 #+BEGIN_SRC emacs-lisp
(use-package minibuffer
	:config
	(minibuffer-electric-default-mode 1)
	(setq completion-styles '(partial-completion substring initials flex))
	(setq completion-category-overrides
				'((file (styles initials basic))
					(buffer (styles initials basic)))))

(use-package orderless
		:ensure
		:custom (setq completion-styles '(orderless))
		:config
		(setq orderless-regexp-separator "[/\s_-]+")
		(setq orderless-matching-styles
					'(orderless-flex
						orderless-strict-leading-initialism
						orderless-regexp
						orderless-prefixes
						orderless-literal)))
	 #+END_SRC
** windows
	 #+BEGIN_SRC emacs-lisp
(use-package emacs
	:init
	(setq display-buffer-alist
				'(("\\*[Hh]elp\\*"
					 (display-buffer-in-side-window)
					 (side . bottom)
					 (slot . -1)
					 (window-height . 0.25))


					("vterm-scratch"
					 (display-buffer-in-side-window)
					 (window-height . 0.3)
					 (side . bottom))

					("\\*Org Src.*"
					 (display-buffer-in-side-window)
					 (window-height . 0.5)
					 (side . bottom))

					("\\*Buffer List\\*"
					 (display-buffer-in-side-window)
					 (side . bottom)
					 (slot . 0)
					 (window-height . 0.25))))
	:bind (("C-c b" . window-toggle-side-windows)))
	 #+END_SRC
* Completetion
** icomplete
	 #+BEGIN_SRC emacs-lisp
(use-package icomplete
	:demand
	:config
	(fido-mode -1)
	(icomplete-mode 1)
	:bind (:map icomplete-minibuffer-map
							("<tab>" . icomplete-force-complete)
							("<return>" . icomplete-force-complete-and-exit) ; exit with completion
							("<right>" . icomplete-forward-completions)
							("<left>" . icomplete-backward-completions)))
	 #+END_SRC
** company
	 #+BEGIN_SRC emacs-lisp
(use-package company
	:ensure
	:after lsp-mode
	:hook (prog-mode . company-mode)
	:bind
	(:map company-active-map
				("<tab>" . company-complete-selection))
	(:map lsp-mode-map
				("<tab>" . company-indent-or-complete-common))
	:custom
	(company-minimum-prefix-length 1)
	(company-idle-delay 0.0))
	 #+END_SRC
* Navigation
** dired
	 config
	 #+BEGIN_SRC emacs-lisp
(use-package dired
	:commands (dired dired-jump)
	:bind (("C-x C-j" . dired-jump))
	:config
	(evil-collection-define-key 'normal 'dired-mode-map
		"h" 'dired-up-directory
		"l" 'dired-find-file)
	:custom
	((dired-listing-switches "-agho --group-directories-first")))
#+END_SRC

  actions
	#+BEGIN_SRC emacs-lisp
(use-package dired
	)
#+END_SRC
** windowmove
	 #+BEGIN_SRC emacs-lisp
;; make moving between and swapping windows easier
(use-package windmove
	:defer
	:bind
	("M-<left>" . 'windmove-left)
	("M-<right>" . 'windmove-right)
	("M-<up>" . 'windmove-up)
	("M-<down>" . 'windmove-down)
	("M-S-<left>" . 'windmove-swap-states-left)
	("M-S-<right>" . 'windmove-swap-states-right)
	("M-S-<up>" . 'windmove-swap-states-up)
	("M-S-<down>" . 'windmove-swap-states-down))
	 #+END_SRC
* Programming
** Project Management
	 #+BEGIN_SRC emacs-lisp
(use-package projectile
	:ensure t
	:diminish
	:config
	(define-key projectile-mode-map (kbd "C-x p") 'projectile-command-map)
	(projectile-mode +1))
	 #+END_SRC
** vterm
	 #+BEGIN_SRC emacs-lisp
(use-package vterm
	:ensure t)

(defun oct/scratch ()
	"Launches a terminal in the bottom window."
	(interactive)
	;; if there is a buffer then kill it
	(when (get-buffer "vterm-scratch")
		(progn
			(let ((proc (get-buffer-process (current-buffer))))
				(when (processp proc)
					(set-process-query-on-exit-flag proc nil)))
			(kill-buffer "vterm-scratch")))
	(vterm "vterm-scratch"))
	 #+END_SRC
** shell
#+BEGIN_SRC emacs-lisp
(use-package flycheck
	:ensure t
	:hook
	(sh-mode . flycheck-mode))
#+END_SRC
** lsp-mode
	 #+BEGIN_SRC emacs-lisp
(defun oct/lsp-mode-setup()
	(setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
	(lsp-headerline-breadcrumb-mode))

(use-package lsp-mode
	:ensure t
	:commands (lsp lsp-deferred)
	:init
	(setq lsp-keymap-prefix "C-c l")
	:hook
	(lsp-mode . oct/lsp-mode-setup))

(use-package company-lsp
	:ensure t
	:commands company-lsp)
	 #+END_SRC
** Go
	 #+BEGIN_SRC emacs-lisp
(use-package go-mode
	:ensure t
	:defer t
	:config
	(setq lsp-gopls-staticcheck t)
	(setq lsp-eldoc-render-all t)
	(setq lsp-gopls-complete-unimported t)
	(defun lsp-go-install-save-hooks ()
		(add-hook 'before-save-hook #'lsp-format-buffer t t)
		(add-hook 'before-save-hook #'lsp-organize-imports t t))
	(add-hook 'go-mode-hook #'lsp-go-install-save-hooks)
	(company-mode 1)
	:hook (go-mode . lsp-deferred))

;; add hook

(use-package company-go :ensure t)
	 #+End_SRC
** elisp
	 use flymake in elisp modes
	 #+BEGIN_SRC emacs-lisp
(use-package flymake
	:commands flymake-mode
	:hook
	(emacs-lisp-mode . flymake-mode))
	 #+END_SRC
	 
delimiters make stuff look better
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
	:ensure
	:hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC
** zig
	 #+BEGIN_SRC emacs-lisp
(use-package lsp-mode
	:config
	(add-to-list 'lsp-language-id-configuration '(zig-mode . "zig"))
	(lsp-register-client
	 (make-lsp-client
		:new-connection (lsp-stdio-connection "~/zls/zig-cache/bin/")
		:major-modes '(zig-mode)
		:server-id 'zls)))
#+END_SRC
** rust
	 #+BEGIN_SRC emacs-lisp
(use-package rust-mode
	:ensure
	:hook
	(rust-mode . lsp-deferred)
	(flycheck-mode . flycheck-rust-setup))

(use-package lsp-rust
	:ensure
	:after lsp-mode)

(use-package flycheck-rust
	:ensure)

;; (use-package lsp-mode
;; 	:config
;; 	(add-to-list 'lsp-language-id-configuration '(rust-mode . "rust"))
;; 	(lsp-register-client
;; 	 (make-lsp-client
;; 		:new-connection (lsp-stdio-connection "~/.cargo/bin/rls")
;; 		:major-modes '(rust-mode)
;; 		:server-id 'rls)))
#+END_SRC
** c++
#+BEGIN_SRC emacs-lisp
(use-package c++-mode
	:hook
	(c++-mode . lsp-deferred))
#+END_SRC
* Git
** Magit
	 Setup magit and get a quick binding to bring it up.
	 #+BEGIN_SRC emacs-lisp
(use-package magit
	:ensure
	:custom
	(magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

(use-package evil-magit
	:ensure
	:after magit)
	 #+END_SRC

	 Make magit show changes within diff line
	 #+BEGIN_SRC emacs-lisp
(use-package magit-diff
	:after magit
	:config
	(setq magit-diff-refine-hunk t))
	 #+END_SRC
* Org
** Working with source code
	 add function 'org-mode-insert-src' and give it a key binding 'C-c s'.
	 this makes it easier to add a sorce code block for this file or for works with other langues
	 #+BEGIN_SRC emacs-lisp
(use-package org-src
	:after org
	:config
	;; make this in the current window
	(setq org-src-window-setup 'current-window)
	(setq org-edit-src-persistent-message nil)
	(setq org-src-fontify-natively t)
	(setq org-src-preserve-indentation t)
	(setq org-src-tab-acts-natively t)
	(setq org-edit-src-content-indentation 0)
	(defun oct/org-mode-insert-src ()
		(interactive)
		(insert "#+BEGIN_SRC emacs-lisp\n")
		(insert "#+END_SRC")
		(previous-line)
		(end-of-line)
		(org-edit-src-code))
	:bind
	("C-c s" . 'oct/org-mode-insert-src))
	 #+END_SRC

