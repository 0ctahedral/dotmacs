* Emacs
** use a custom file
#+BEGIN_SRC emacs-lisp
(use-package emacs
  :init
  (setq custom-file
	"~/.emacs.d/custom-settings.el")
  (load custom-file t))
#+END_SRC
** setup
#+BEGIN_SRC emacs-lisp
(use-package emacs
    :config
    (show-paren-mode 1)
    (setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
    (electric-pair-mode 1))
#+END_SRC
** variables
#+BEGIN_SRC emacs-lisp
  (defvar conf "~/.emacs.d/init-def")
  (defvar init-el (concat conf ".el"))
  (defvar init-org (concat conf ".org"))
	(setq font-scale 120)
#+END_SRC
** editing this file
#+BEGIN_SRC emacs-lisp
(use-package emacs
:config
(defun oct/init ()
    "Edit `org-file' in the current buffer"
    (interactive)
    (find-file init-org)))
#+END_SRC
** executing this file
I need a way to compile and then execute the whole init file.
this is helful for testing if I've fucked it up yet.
#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :config
    (defun oct/exec-init ()
    (interactive)
      (org-babel-load-file init-org)))
#+END_SRC
* GUI
** Remove annoying UI stuff and set theme
#+BEGIN_SRC emacs-lisp
(use-package emacs
    :config
    (tool-bar-mode -1)
    (menu-bar-mode -1)
    (blink-cursor-mode -1)
    (scroll-bar-mode -1)
    (setq inhibit-startup-screen t)
    (setq ring-bell-function 'ignore))
#+END_SRC
** Set font properties and keybinds
#+BEGIN_SRC emacs-lisp
	(use-package emacs
		:config
		;; set font scale to default
		(set-face-attribute 'default (selected-frame) :height font-scale)
		;; functions for font scale
		(defun oct/inc-scale ()
			"increases the frame's font scale"
			(interactive)
			(setq font-scale (+ font-scale 10))
			(set-face-attribute 'default (selected-frame) :height font-scale))
		(defun oct/dec-scale ()
			"decreases the frame's font scale"
			(interactive)
			(setq font-scale (- font-scale 10))
			(set-face-attribute 'default (selected-frame) :height font-scale))

		(set-face-attribute 'default nil :family "Hack" :height font-scale)
		:bind
		("C-=" . 'oct/inc-scale)
		("C--" . 'oct/dec-scale))
#+END_SRC

** olivetti
#+BEGIN_SRC emacs-lisp
(use-package olivetti
  :ensure t)
#+END_SRC
** diminish
#+BEGIN_SRC emacs-lisp
	(use-package diminish :ensure)
	(use-package undo-tree :diminish)
#+END_SRC
** Themes
*** custom themes
we want to be able to load whatever custom themes we have so add them to the path
#+BEGIN_SRC emacs-lisp
	;; add theme directory
	(add-to-list 'custom-theme-load-path "~/.emacs.d/themes/")
	(add-to-list 'load-path "~/.emacs.d/themes/")
#+END_SRC

function to load a given theme
#+BEGIN_SRC emacs-lisp
	(defun oct/load-theme-silent (theme)
		"Reloads a THEME given by the user."
		(interactive
		 (list
			(intern
			 (completing-read "Load custom theme: "
															(mapcar #'symbol-name
																			(custom-available-themes))))))
		(load-theme theme t))
#+END_SRC

function to load a theme from the current file
#+BEGIN_SRC emacs-lisp
	(defun oct/load-theme-from-curr ()
		(interactive)
		(intern
		(oct/load-theme-silent (substring 
						 (file-name-nondirectory
							(buffer-file-name))
						 0 -9))))
#+END_SRC
*** Set the theme
#+BEGIN_SRC emacs-lisp
	;; get this dope theme
	;; (use-package modus-vivendi-theme
	;; 		:ensure t)
	(oct/load-theme-silent 'underwater)

#+END_SRC
*** rainbow-mode
#+BEGIN_SRC emacs-lisp
		(use-package rainbow-mode
			:ensure
			:diminish
			:commands rainbow-mode
			:config
			(setq rainbow-ansi-colors nil)
			(setq rainbow-x-colors nil)
			(setq-default rainbow-mode 1))
#+END_SRC
** line numbers
#+BEGIN_SRC emacs-lisp
	(use-package display-line-numbers
		:hook
		(prog-mode-hook . display-line-numbers-mode))
#+END_SRC
** font

* Editor
** evil-mode
#+BEGIN_SRC emacs-lisp
;; vim fusion
(use-package evil
  :ensure t
  :config
  (evil-mode 1)
  (define-key evil-normal-state-map [escape] 'keyboard-quit)
  (define-key evil-visual-state-map [escape] 'keyboard-quit)
  (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit))
#+END_SRC
** settings
#+BEGIN_SRC emacs-lisp
	(use-package emacs
		:config
		(setq-default tab-width 2)
		(setq-default c-basic-offset 2)
		(setq-default indet-tabs-mode nil))
#+END_SRC
* Buffers
** Functions
kill-curr-buff kills the current buffer and closes its window.
#+BEGIN_SRC emacs-lisp
(use-package emacs
    :config
    (defun oct/kill-curr-buff (&optional arg)
	"Kill the current buffer"
	;; make interactive, set arg to ???
	(interactive "p")
	;; we can't kill a minibuffer so abort it
	;; otherwise kill the buffer
	(if (minibufferp)
	    (abort-recursive-edit)
	(kill-buffer (current-buffer)))
	;; if there are other windows we can kill this one
	(when (and arg
		(not (one-window-p)))
		(delete-window)))

    :bind ("M-k" . oct/kill-curr-buff))
#+END_SRC
** IBuffer
Settings for ibuffer
#+BEGIN_SRC emacs-lisp

;; ibuffer stuff
(use-package ibuffer)

#+END_SRC
** MiniBuffer
#+BEGIN_SRC emacs-lisp
(use-package minibuffer
  :config
  (use-package orderless
    :ensure
    :custom (setq completion-styles '(orderless))
    :config
    (setq orderless-regexp-separator "[/\s_-]+")
    (setq orderless-matching-styles
          '(orderless-flex
            orderless-strict-leading-initialism
            orderless-regexp
            orderless-prefixes
            orderless-literal)))
(minibuffer-electric-default-mode 1))
#+END_SRC
* Completetion
** icomplete
#+BEGIN_SRC emacs-lisp
  (use-package icomplete
    :demand
    :config
    (fido-mode -1)
    (icomplete-mode 1)
    :bind (:map icomplete-minibuffer-map
		("<tab>" . icomplete-force-complete)
		("<return>" . icomplete-force-complete-and-exit) ; exit with completion
		("<right>" . icomplete-forward-completions)
		("<left>" . icomplete-backward-completions)))
#+END_SRC
** company
#+BEGIN_SRC emacs-lisp
	(use-package company
		:ensure t
		:config
		(company-mode 1)
		(define-key company-active-map (kbd "<tab>") 'company-complete-common-or-cycle)
		(global-company-mode 1)
		(setq company-idle-delay 1)
		(setq company-minimum-prefix-length 1))
#+END_SRC
* Navigation
** dired

** windowmove
#+BEGIN_SRC emacs-lisp
;; make moving between and swapping windows easier
(use-package windmove
  :defer
  :bind
  ("M-<left>" . 'windmove-left)
  ("M-<right>" . 'windmove-right)
  ("M-<up>" . 'windmove-up)
  ("M-<down>" . 'windmove-down)
  ("M-S-<left>" . 'windmove-swap-states-left)
  ("M-S-<right>" . 'windmove-swap-states-right)
  ("M-S-<up>" . 'windmove-swap-states-up)
  ("M-S-<down>" . 'windmove-swap-states-down))
#+END_SRC
** windows
#+BEGIN_SRC emacs-lisp
	(use-package emacs
		:init
		(setq display-buffer-alist
					'(("\\*[Hh]elp\\*"
						 (display-buffer-in-side-window)
						 (side . bottom)
						 (slot . -1)
						 (height . 0.25))

						("^\*Org Src"
						 (display-buffer-in-side-window)
						 (side . left))

						("\\*Buffer List\\*"
						 (display-buffer-in-side-window)
						 (side . bottom)
						 (slot . 0)
						 (height . 0.25))
						))
		:bind (("C-c C-b" . window-toggle-side-windows))
		)
#+END_SRC
* Programming
** Project Management
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
	:diminish
  :config
  (define-key projectile-mode-map (kbd "C-x p") 'projectile-command-map)
  (projectile-mode +1))
#+END_SRC
** lsp-mode
#+BEGIN_SRC emacs-lisp
	(use-package lsp-mode
		:ensure t
		:commands (lsp lsp-deferred)
		:hook (go-mode-hook . lsp))

	(use-package company-lsp
		:ensure t
		:commands company-lsp)
#+END_SRC
** Go
#+BEGIN_SRC emacs-lisp
	(use-package go-mode
		:ensure t
		:defer t
		:config
		(setq lsp-gopls-staticcheck t)
		(setq lsp-eldoc-render-all t)
		(setq lsp-gopls-complete-unimported t)
		(defun lsp-go-install-save-hooks ()
			(add-hook 'before-save-hook #'lsp-format-buffer t t)
			(add-hook 'before-save-hook #'lsp-organize-imports t t))
		(add-hook 'go-mode-hook #'lsp-go-install-save-hooks)
		(company-mode 1))

	;; add hook

	(use-package company-go :ensure t)
#+End_SRC
** elisp
use flymake in elisp modes
#+BEGIN_SRC emacs-lisp
	(use-package flymake
		:commands flymake-mode
		:hook
		(emacs-lisp-mode-hook . flymake-mode))
#+END_SRC
* Git
** Magit
Setup magit and get a quick binding to bring it up.
#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure
  :bind ("C-c g" . magit-status))
#+END_SRC
Make magit show changes within diff line
#+BEGIN_SRC emacs-lisp
(use-package magit-diff
  :after magit
  :config
  (setq magit-diff-refine-hunk t))
#+END_SRC
* Org
** add src
add function 'org-mode-insert-src' and give it a key binding 'C-c s'.
this makes it easier to add a sorce code block for this file or for works with other langues
#+BEGIN_SRC emacs-lisp
	(use-package org
		:config
		(defun oct/org-mode-insert-src ()
			(interactive)
			(insert "#+BEGIN_SRC emacs-lisp\n")
			(insert "#+END_SRC")
			(previous-line)
			(end-of-line)
			(org-edit-src-code))
		:bind
		("C-c s" . 'oct/org-mode-insert-src))
#+END_SRC
